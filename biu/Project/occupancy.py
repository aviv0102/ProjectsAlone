"""
Written by:
    Aviv Shisman
"""

# imports:
import numpy as np
from sklearn.svm import SVR
import datetime
from isoweek import Week
import generate_data
import time


# model params:
accuracy_factor = 10  # how much weeks to consider in feature vec, high value will give better accuracy
                        # but will need more data

assumption_size = 4  # how many assumptioned weeks more (after next 7 days that are more accurate)

interval = 3600          # run prediction every 3600 sec = 1 hour

input_table = "data.csv" # from where to learn data (no need to change)



'''
Getting data from data file, predict occupancy for next weeks by it.

input-> data.csv , updated each hour for all the offices
output -> pred.csv , our predictions
'''
def main():
    print("Hello!, please make sure you have:\n")
    print("1. data/real_data.csv - file that contains all the data for all offices")
    print("2. offices.txt - file that contains all office ids separated by new line for each(generated by get_data.py)")
    print("3. holidays.csv - file with all holidays dates for next 10 year,"
          "was taken from https://www.hebcal.com/ical/ \n\n")

    while True:

        # each run get updated data
        # get_data.activate() --> when you will have enough consistent data(entry for every hour in the day)
        generate_data.activate()

        # get offices.txt id's
        office_ids = []
        office_ids_file = open("offices.txt", 'r')
        for line in office_ids_file.readlines():
            office_ids.append(line.rstrip('\n'))
        office_ids_file.close()

        # prediction for each office...
        results = []
        for id in office_ids:
            # creating a model for each office, training it by all the data and predicting

            data = load_data(id)  # getting data relevant only for that office
            X, Y = extract_train(data)  # getting train vectors from data

            np.random.seed(0)
            SvmRegressor = SVR(gamma='scale', C=1.0, epsilon=0.2)
            SvmRegressor.fit(X, Y)  # train

            # prediction
            pred, det = get_prediction(SvmRegressor, data)
            results.append((pred, det, id))

        final = monthly_assumption(results)  # not accurate predictions for after next 7 days
        write_results(final)

        print('Done, results in : prediction.csv')
        time.sleep(interval)

    return


'''
load data from data.csv
'''
def load_data(office_id):
    dataFile = open(input_table, "r")
    data = []
    for line in dataFile.readlines():
        entry = line.rstrip('\n').split(',')
        try:
            if entry[0] == office_id:  # learn only data from the specific office
                entry.remove(entry[0])  # we don't the id anymore
                entry = list(map(int, entry))
                data.append(entry)
        except Exception:
            continue

    dataFile.close()

    return data


'''
predicting using the model and the test vectors
'''
def get_prediction(model, data):
    candidates, details = extract_prediction_candidates(data)
    predictions = model.predict(candidates)

    return predictions, details


'''
Write results in to pred.csv
'''
def write_results(results):
    output = open("prediction.csv", "w")
    output.write(",".join(("office_id", "week", "day", "hour", "prediction" ,"date"+ "\n")))
    for predArr, dataArr, id in results:
        for pred, data in zip(predArr, dataArr):
            output.write(",".join((str(id), str(data[0]), str(data[1]), str(data[2]), str(pred),data[3] + '\n')))

    output.close()

    return


'''
in the training stage we give the models pairs of x,y
x -> a list of the occupancy in last 10 weeks in the same hour and day (feature vec)
y -> the occupancy of the of this example (the real answer - thats how to model will learn...)

so this stage is extracting those pairs out of the data set.
'''
def extract_train(data):
    # getting data sorted for training, each entry is (week,day,hour, occupancy) for that office
    X = []
    Y = []
    first_year_in_data = data[0][4]
    for i, entry in enumerate(data):

        # we only learn examples that have X previous weeks of data before them
        if entry[0] <= accuracy_factor and entry[4] == first_year_in_data:
            continue

        # getting the number of people in the prev 10 weeks of the same hour and day as a feature vec
        example = []
        example_tag = []
        curr_week = entry[0]
        curr_day = entry[1]
        curr_hour = entry[2]
        for sample in data:
            if sample[2] == curr_hour and sample[1] == curr_day:
                if check_distance_of_weeks(curr_week,sample[0],entry[4],sample[4],accuracy_factor):
                    # adding to the feature vec the number of pepole in the prev weeks as feature
                    example.append(sample[3])

        example_tag.append(entry[3])
        X.append(example)
        Y.append(example_tag[0])

    return np.array(X), np.array(Y)

'''
help function that check if the distance of weeks is valid
'''
def check_distance_of_weeks(curr_week,other_week,curr_year,other_year,distance):
    if curr_year > other_year:
        curr_week = 52*(curr_year-other_year)+curr_week
    elif other_year > curr_year:
        other_week =52*(other_year - curr_year)+ other_week

    if distance >= curr_week - other_week > 0:
        return True

    return False


'''
this function will work every hour, it will get the info needed to predict occupancy for the next 7 days

how?
it will get the 9 prev weeks + this week for every hour in the last 7 days -> we will use it to predict the
following days
'''
def extract_prediction_candidates(data):
    # get current time measures
    closest_hour, week_num, curr_day,curr_year = get_time()

    X = []        # array of vectors
    details = []  # details of every prediction

    for i, entry in enumerate(data):

        entry_week = entry[0]
        entry_day = entry[1]
        entry_hour = entry[2]

        # valid - last 7 days
        if not (check_valid(closest_hour, week_num, curr_day, curr_year,entry)):
            continue

        # getting occupancy of 10 prev weeks including this week("entry_week")
        example = []
        for sample in data:
            if sample[2] == entry_hour and sample[1] == entry_day:
                if check_distance_of_weeks(entry_week,sample[0],entry[4],sample[4],accuracy_factor-1):
                    example.append(sample[3])
        example.append(entry[3])

        details.append((entry_week + 1, entry_day, entry_hour))
        X.append(example)

    return np.array(X), details


'''
get all the measurements of current time : week number(1 to 52), closet hour , which day in week,year 
'''
def get_time():
    # get time and date (round time to nearest hour)
    now = datetime.datetime.now()
    now = now.replace(second=0, microsecond=0, minute=0, hour=now.hour) + datetime.timedelta(hours=now.minute // 30)
    date, time_now = now.strftime("%d/%m/%Y %H:%M:%S").split(' ')
    date = date.split('/')
    time_now = int(time_now.split(':')[0])
    week_num = datetime.date(int(date[2]), int(date[1]), int(date[0])).isocalendar()[1]

    hours = [i for i in range(8,21)]
    closest_hour = 0
    min = 999
    for h in hours:
        if abs(time_now - h) < min:
            min = abs(time_now - h)
            closest_hour = h

    curr_day = datetime.datetime.today().weekday() + 2

    return closest_hour, week_num, curr_day,int(date[2])


'''
check if entry is in the last 7 days
'''
def check_valid(closest_hour, week_num, curr_day, curr_year,entry):

    entry_week = entry[0]
    entry_day = entry[1]
    entry_hour = entry[2]
    entry_year = entry[4]

    if curr_year > entry_year:
        week_num= 52*(curr_year-entry_year)+week_num
    elif entry_year> curr_year:
        entry_week =52*(entry_year - curr_year)+ entry_week

    # if not in last week or this week it not last 7 days
    if entry_week != week_num and entry_week != week_num - 1:
        return False
    # if more than 7 days ago
    if entry_week == week_num - 1 and entry_day < curr_day:
        return False
    # if 7 days ago but few hours before
    if entry_week == week_num - 1 and entry_day == curr_day and entry_hour < closest_hour:
        return False

    # if more advanced than this day
    if entry_week == week_num and entry_day > curr_day:
        return False
    # if more advanced than this hour
    if entry_week == week_num and entry_day == curr_day and entry_hour > closest_hour:
        return False

    return True


'''
get assumption (for days after next 7) using previous predictions and holidays dates
'''
def monthly_assumption(results):
    # params:
    new_results = []
    holidays = load_holidays()

    # get current year for later
    now = datetime.datetime.now()
    date, time = now.strftime("%m/%d/%Y %M:%H:%S").split(' ')
    year_curr = int(date.split('/')[2])

    # less accurate prediction for next weeks , using prediction and holidays:
    for office_results in results:
        what_we_had = []  # prevent copied entries later in code...
        for i in range(assumption_size):

            # getting old prediction and its details for the specific office
            prediction = list(office_results[0])
            details = office_results[1]
            office_id = office_results[2]

            # creating the new predictions
            new_details = []
            index_pred =0                           # to match the details to prediction
            for j, entry in enumerate(details):

                elm = (entry[0] + i, entry[1], entry[2])
                date = get_date(year_curr , elm[0] , elm[1])
                elm = (elm[0],elm[1],elm[2],date)

                if not (elm in what_we_had):  # if not have prediction for this date include it
                    new_details.append(elm)
                    what_we_had.append(elm)
                else:                           # else prediction already exists remove copy's prediction
                    prediction.remove(prediction[j])
                    continue

                # check if holiday and if it does apply_rule (function in check_holiday)
                if(check_holiday(date, prediction, index_pred, holidays)):
                    new_details[index_pred] = (elm[0],elm[1],elm[2],date +' H')  # update details


                index_pred  += 1

            # ignore the predictions floating point and sum up results
            for i,single_prediction in enumerate(prediction):
                prediction[i] = int(round(single_prediction))

            new_results.append((prediction, new_details, office_id))

    return new_results


'''
load holidays.csv
'''
def load_holidays():
    hol = []
    holidays_file = open('holidays.csv', 'r')
    holidays_file.readline()

    # loading holidays dates and adjusting the formats
    for line in holidays_file.readlines():
        line = line.split(',')
        line = (line[0].replace('"', ''), line[1].replace('"', ''))
        date = line[1].split('/')
        if int(date[0]) < 10:
            date[0] = '0' + date[0]

        if int(date[1]) < 10:
            date[1] = '0' + date[1]

        date = '/'.join((date[0], date[1], date[2]))
        line = (date, line[0])
        hol.append(line)

    holidays_file.close()

    return hol


'''
check if holiday and if it does apply rule.
'''
def check_holiday(date, predictions, index, holidays):

    for holiday_date, holiday_name in holidays:
        if holiday_date == date:
            apply_rule(predictions, index, holiday_name)
            return True

    return False


'''
apply to prediction the effect of the holiday
'''
def apply_rule(predictions, index, holiday_name):
    try:
        old_value = predictions[index]
    except Exception:
        print('')
    importent = ['Pesach','Shavuot','Rosh Hashana','Yom Kippur','Sukkot','Chanukah']
    less_importent =['Purim','Tu BiShvat','Esther','Lag BaOmer','Simchat','Yom HaShoah'
        ,'Yom HaZikaron','Yom HaAtzma','Yom']
    others = ['Rosh Chodesh','Shabbat']

    for name in importent:
        if name in holiday_name:
            predictions[index] = 0.2 * old_value    # most pepole will don't go to office in these holidays
            return

    for name in less_importent:
        if name in holiday_name:
            predictions[index] = 0.6 * old_value    # holidays that some have a day of or pepole don't go
            return

    for name in others:
        if name in holiday_name:
            predictions[index] = 0.9 * old_value    # less importent things
            return

    predictions[index] = 0.75 * old_value

    return


'''
get date by week number, year , and which day it is
'''
def get_date(current_year, week_num, weekday):
    if weekday == 1:
        ans = Week(current_year, week_num - 1).sunday()  # the week starts from monday in iso method
    elif weekday == 2:
        ans = Week(current_year, week_num).monday()
    elif weekday == 3:
        ans = Week(current_year, week_num).tuesday()
    elif weekday == 4:
        ans = Week(current_year, week_num).wednesday()
    elif weekday == 5:
        ans = Week(current_year, week_num).thursday()
    elif weekday == 6:
        ans = Week(current_year, week_num).friday()
    elif weekday == 7:
        ans = Week(current_year, week_num).saturday()

    ans = ans.strftime("%m/%d/%Y %M:%H:%S").split(' ')[0]

    return ans


if __name__ == '__main__':
    main()
